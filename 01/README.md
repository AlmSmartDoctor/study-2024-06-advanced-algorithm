# 분할정복 그리디

---

![Untitled](https://github.com/AlmSmartDoctor/study-2024-06-advanced-algorithm/assets/55384167/46611c43-d19b-40f3-b632-1dd860eaa891)

주어진 문제를 둘 이상의 부분 문제로 나눈 뒤 각 문제에 대한 답을 재귀 호출을 이용해 계산하고, 각 부분 문제의 답으로부터 전체 문제의 답을 계산

# [**예제: 병합 정렬과 퀵 정렬**]

주어진 수열을 크기 순서대로 정렬하는 문제는 전산학에서 가장 유명한 문제

- `병합 정렬(Merge Sort)`
  - 병합 정렬 알고리즘은 주어진 수열을 가운데에서 쪼개 비슷한 크기의 수열 두 개로 만든 뒤 이들을 재귀 호출해서 각각 정렬
    그 후 정렬된 배열을 하나로 합쳐서 전체 수열을 얻는다.
- `퀵 정렬(Quick Sort)`
  - 퀵 정렬 알고리즘은 배열을 단순히 가운데서 쪼개는 대신, 병합 과정이 필요 없도록 한쪽의 배열에 포함된 수가 다른 쪽 배열의 수보다 항상 작도록 배열을 분할
    이를 위해 퀵 정렬은 파티션(partition)이라 부르는 단계를 도입하는데, 이는 배열에 있는 수 중 임의의 '기준 수(pivot)'를 지정한 후 기준보다 작거나 같은 숫자를 왼쪽, 더 큰 숫자를 오른쪽으로 보내는 과정임

이 두 알고리즘은 모두 분할 정복 패러다임을 기반으로 해서 만들어 졌다.

![Untitled](https://github.com/AlmSmartDoctor/study-2024-06-advanced-algorithm/assets/55384167/2a75c177-bb23-43e6-8552-b274061e5ff3)

### **시간 복잡도 분석**

병합 정렬의 경우 한 단계에서 필요한 총 시간은 O(N)이고 이는 일정하다. 그리고 문제의 크기는 항상 거의 절반으로 나누어 지기 때문에, 필요한 단계의 수는 O(lgN)이 된다.

병합 정렬의 전체 시간복잡도는 O(NlgN)이 된다.

퀵 정렬의 경우 대부분의 시간을 차지하는 것은 주어진 문제를 두 개의 부분 문제로 나누는 부분이다. 병합 정렬과 달리 퀵 정렬의 시간 복잡도를 분석하기 어려운 것은 결과적으로 분할된 두 부분 문제가 비슷한 크기로 나눠진다는 보장을 할 수 없기 때문이다.

기준으로 택한 원소가 최소 원소나 최대 원소인 경우 부분 문제의 크기가 하나씩만 줄어들 수 있기 때문이다.

최악의 경우 퀵 정렬의 시간 복잡도는 O(N^2)이 된다. 다행히 평균적으로 부분 문제가 절반에 가깝게 나눠질 때 퀵 정렬의 시간 복잡도는 병합 정렬과 같은 O(NlgN)이 된다.

따라서 대부분의 퀵 정렬 구현은 가능한 한 절반에 가까운 분할을 얻기 위해 좋은 기준을 뽑는 다양한 방법들을 사용한다.

### [**예제 : 카라츠바의 빠른 곱셈 알고리즘**]

`카라츠바의 빠른 곱셈 알고리즘`은, 두 개의 정수를 곱하는 알고리즘

이 연산은 수백 자리나 수만 자리 정도의 큰 숫자들을 다룰 때 주로 사용한다.

![Untitled](https://github.com/AlmSmartDoctor/study-2024-06-advanced-algorithm/assets/55384167/6c33ad22-d11b-45da-92f5-2315ee1dfd20)

a = a*1 * 10^{128} + a*0\
b = b_1 * 10^{128} + b_0

카라츠바는 이 때 $a \times b$ 를 네 개의 조각을 이용해 표현하는 방법을 살펴봄

예를 들어 다음과 같이 표현할 수 있다.

a _ b = (a_1 _ 10^{128} + a*0) * (b*1 * 10^{128} + b*0) = a_1 * b*1 * 10^{256} + (a*1 * b*0 + a_0 * b*1) * 10^{128} +a*0 * b_0

이 방법에서 큰 정수 두 개를 한 번 곱하는 대신, 절반 크기로 나눈 작은 조각을 네 번 곱한다.

이대로 각각을 재귀 호출해서 해결하면 분할 정복 알고리즘이라고 할 수 있다.

이 방법의 시간복잡도는 계산해 보면 O(n^2)이 된다.

결국 시간복잡도가 줄어들지 않았으므로 의미가 없음

카라츠바가 발견한 것은 다음과 같이 a \* b를 표현했을 때 네 번 대신 세 번의 곱셈으로만 이 값을 계산할 수 있다는 것

a _ b = a_1 _ b*1 * 10^{256} + (a*1 * b*0 + a_0 * b*1) * 10^{128} +a*0 * b*0 = z_2 * 10^{256} + z_1 \*10^{128} + z_0

이렇게 되면 곱셈을 세 번밖에 쓰지 않는다. 이 세 결과를 다시 적절히 조합해 원래 두 수의 답을 구해낼 수 있다.

### **시간 복잡도 분석**

카라츠바 알고리즘은 두 개의 입력을 절반씩으로 쪼갠 뒤, 세 번 재귀 호출을 하기 때문에 재귀 호출을 한 번이나 두 번만 하던 지금까지의 방식과 다르게 계산해야 한다.

우선 카라츠바 알고리즘의 수행 시간을 병합 단계와 기저 사례의 두 부분으로 나눈다.

자릿수 n이 2의 거듭제곱 2^k라고 했을 때, 재귀 호출의 깊이는 k가 된다.

한 번 쪼갤 때 마다 해야 할 곱셈의 수가 세 배씩 늘어나기 때문에 마지막 단계에는 3^k개의 부분 문제가 있는데, 마지막 단계에서는 두 수 모두 한 자리니까 곱셈 한 번이면 충분하다.

따라서 곱셈의 수는 O(3^k)가 된다.

n = 2^k라고 가정했으니 k=log n 이고 이 때 곱셈의 수를 n에 대해 표현하면 다음과 같은 식이 된다.

O(3^k) = O(3^log n) = O(n^log 3)

log3 = 1.585 정도의 값이기 때문에 카라츠바 알고리즘이 O(n^2)보다 훨씬 적은 곱셈을 필요로 한다.

각 단계에 해당하는 숫자의 길이를 모두 더하면 병합 단계에 드는 시간을 계산할 수 있다.

단계가 내려갈 때마다 숫자의 길이는 절반으로 줄고 부분 문제의 갯수는 세 배 늘기 때문에 i 번째 단계에서 필요한 연산의 수는 {3 / 2})^i \* n 이 된다. 따라서 이 함수는 결국 nlog 3과 같은 속도로 증가한다

![Untitled](https://github.com/AlmSmartDoctor/study-2024-06-advanced-algorithm/assets/55384167/665bb3ff-c3c9-481f-bd9b-28111ac90aec)

. 따라서 카라츠바 알고리즘의 시간 복잡도는 곱셈이 지배하며, 최종 시간 복잡도는 O(n^log 3)이 된다.

---

# 그리디

각 단계마다 답의 한 부분을 만들어 간다는 점에서 완전 탐색이나

동적 계획법 알고리즘과 다를 것이 없지만 모든 선택지를 고려해 보고 그중 전체 답이 가장 좋은 것을 찾는 두 방법과는 달리,

탐욕법은 각 단계마다 지금 당장 가장 좋은 방법만을 선택

탐욕적 알고리즘이 사용되는 경우는 크게 다음 두 가지로 제한된다

- 탐욕법을 사용해도 항상 최적해를 구할 수 있는 문제를 만난 경우, 탐욕법은 동적 계획법보다 수행시간이 훨씬 빠르기 때문에 유용하다
- 시간이나 공간적 제약으로 인해 다른 방법으로 최적해를 찾기 너무 어렵다면 최적해 대신 적당히 괜찮은 답을 찾는 것으로 타협할 수 있다. 탐욕법은 이럴때 최적은 아니지만 임의의 답보다는 좋은 답을 구하는 용도로 유용하게 쓰인다

보통 알고리즘 문제에서는 첫번째 용도로만 사용

![Untitled](https://github.com/AlmSmartDoctor/study-2024-06-advanced-algorithm/assets/55384167/48151e0b-dca1-470d-a5f2-546eebe5374a)

그리디로 구할 수 없는 문제도 존재한다

예를들어 트리 구조에서 가장 큰 합을 구하는 문제

## **회의실 예약 - 활동 선택 문제(activity selection problem)**

회사에 회의실이 하나밖에 없는데, n(<=100)개의 팀이 각각 회의하고 싶은 시간을 다음과 같이 제출했다고 하자. 두 팀이 회의실을 같이 쓸 수 없기 때문에 이 중 서로 겹치지 않는 회의들만을 골라내서 진행해야 한다. 최대 몇 개나 선택할 수 있을까?

![https://blog.kakaocdn.net/dn/dNu1gp/btrifnLwPNl/R8veyh5WgwkwLFtDNs7wWK/img.png](https://github.com/AlmSmartDoctor/study-2024-06-advanced-algorithm/assets/55384167/cd203792-5255-4665-a47c-afc9b779806a)

회의실 예약 - 활동 선택 문제

해당 문제의 답은 여러 방법이 존재할 수 있다. 서로 겹치지 않은 회의들의 집합은 모두 이 문제의 답이라고 할 수 있다. 이때 우리가 원하는 가장 좋은 답, 곧 최적해는 크기가 가장 큰 부분 집합이다.

### **무식하게 풀기?**

무식하게 푸는 방법은 모든 부분 집합을 하나하나 만들어 보며 그중 회의들이 겹치지 않는 답들을 걸러내고 가장 큰 부분 집합을 찾아낸다. 그러나 집합의 크기가 n일 때 부분 집합의 수는 2^n이기 때문에 n이 30만 되어도 10억정도가 넘게 되어 시간 안에 풀기 힘들다.

## **탐욕적 알고리즘 구상**

이런 문제를 '탐욕적으로' 해결하는 방법을 몇 가지 떠올릴 수 있다.

1. 길이가 짧은 회의부터 하나하나 순회하면서 앞의 것들과 겹치지 않는 것들을 추가하기
2. 길이와 상관없이 가장 먼저 끝나는 회의부터 선택하기

첫 번째 방법은 그럴듯해 보이지만 짧은 회의가 긴 회의 두 개 사이에 위치하게 된다면 해당 방법은 최적해에 속하지 않으므로 사용하기 부적절하다.

![https://blog.kakaocdn.net/dn/elhXX5/btribzTwEQd/52lhFMineL1QG9kCkN1F31/img.png](https://github.com/AlmSmartDoctor/study-2024-06-advanced-algorithm/assets/55384167/752d4c59-2f03-4776-9ea7-bc18fc327a60)

그래서 **두 번째 방법**을 선택해야 한다. 가장 먼저 끝나는 회의를 선택하고, 이 회의와 겹치는 것들을 모두 지운 뒤 다시 이 중에서 먼저 끝나는 회의를 선택하기를 반복하는 것이다.

1. 목록 S에 남은 회의 중 가장 일찍 끝나는 회의 S_min을 선택한다.
2. S_min과 겹치는 회의를 S에서 모두 지운다.
3. S가 텅 빌 때까지 반복한다.

탐욕적 알고리즘 방식을 선택하였으니 이제 해당 방법이 항상 최적해를 찾아낼 수 있다는 정당성을 두 가지 속성을 통해 증명해주면 된다.

### **1. 탐욕적 선택 속성 (greedy choice property)**

처음으로 증명해야 할 속성은 동적 계획법처럼 답의 모든 부분을 고려하지 않고 탐욕적으로만 선택하더라도 최적해를 구할 수 있다는 것이다.

이 속성은 매우 중요하기 때문에 따로 이름을 붙여 **탐욕적 선택 속성**이라고 부름

어떤 알고리즘에 이 속성이 성립할 경우, 우리가 각 단계에서 탐욕적으로 내리는 선택은 항상 최적해로 가는 길 중 하나이다.

따라서 탐욕적인 선택을 해서 '손해'를 볼 일이 없다는 것을 알 수 있다. 따라서 앞에서 제안한 알고리즘의 경우, 탐탐욕적 선택 속성이 성립한다는 말은 다음 조건이 성립한다는 의미이다.

- **가장 종료 시간이 빠른 회의(S_min)를 포함하는 최적해가 반드시 존재한다.**

### **증명**

S의 최적해 중에 S_min을 포함하지 않는 답이 있다고 가정하자. 이 답은 서로 겹치지 않은 회의의 목록으로 첫 번째로 개최되는 회의를 지우고 S_min을 대신 추가해서 새로운 목록을 만들자.

해당 그림은 위의 예제에 속하는 S_min을 포함하지 않는 최적해 중 하나이다.

![https://blog.kakaocdn.net/dn/bgAjdO/btrihbjeCMM/RckopynBAxPgkgl7qZvTxk/img.png](https://github.com/AlmSmartDoctor/study-2024-06-advanced-algorithm/assets/55384167/5b829fd4-6dbb-4643-9ad4-56bfeb19f565)

총 3개의 회의실 배정이 가능한 최적해

S_min은 S에서 가장 일찍 끝나는 회의이기 때문에 지워진 회의는 S_min보다 일찍 끝날 수는 없다.  따라서, 해당 최적해에서 첫 번째로 개최되는 회의를 지우고 S_min을 추가하면 다음과 같이 된다.

![https://blog.kakaocdn.net/dn/qW6gL/btrifoKpNsZ/08C3n02gLzrKNUkWGHOSL1/img.png](https://github.com/AlmSmartDoctor/study-2024-06-advanced-algorithm/assets/55384167/cb1a2d53-8a7f-47a1-b03a-d24ed9130d77)

해당 최적해에서 첫 번째로 개최되는 회의를 지우고 S_min 추가하기

→ 따라서 두 번째 회의와 S_min을 겹치는 일은 없으며, 새로 만든 목록도 최적해 중 하나가 된다.

→  따라서 항상 S_min을 포함하는 최적해가 존재한다. 이와 같은 증명은 가장 일찍 끝나는 회의를 선택해서 최적해를 얻는 것이 불가능해지는 경우는 없음을 나타낸다.

### **2. 최적 부분 구조 (optimal substructure)**

이렇게 탐욕적인 방법으로 선택하는 것이 항상 최적의 답을 줄 수 있다고 해서 증명이 끝난 것은 아니다.

항상 최적의 선택만을 내려서 전체 문제의 최적해를 얻을 수 있음을 보여야 한다.

당연하지만 경우에 따라 성립하지 않은 경우도 있기 때문이다.

최적 부분 구조는 DP에서 다루듯이 부분 문제의 최적해에서 전체 문제의 최적해를 만들 수 있음을 보여주면 된다.

다행히 이 속성은 대게 매우 자명해서 따로 증명할 필요가 없는 경우가 대부분이다.

첫 번째 회의를 잘 선택하고 겹치는 회의를 모두 걸러냈다면, 남은 회의 중에 당연히 최대한 많은 회의를 선택하게 되므로 최적 부분 구조가 성립함을 알 수 있다.
